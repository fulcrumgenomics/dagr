/*
 * The MIT License
 *
 * Copyright (c) 2016 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package dagr.tasks

import dagr.core.tasksystem.{Pipeline, Task}

import scala.collection.mutable.ListBuffer

/**
 * Provides a set of objects and classes for composing Scatter/Gather tasks and pipelines.
 */
object ScatterGather {

  /**
   * A type of Task that, when run, partitions some kind of input, and produces one or more outputs
   * of type A that should be parallelized (scattered) over.
   */
  trait Partitioner[A] extends Task {
    def partitions: Option[Seq[A]]
  }

  /** Provides a factory method to create a Scatter object from a Partitioner. */
  object Scatter {
    def apply[A](partitioner: Partitioner[A]): Scatter[A] = new PartitionerWrapper(partitioner)
  }


  /**
   * One of the two main types that implement Scatter/Gather, Scatter provides methods
   * for mapping the currently scattered type to a new type by running a task in parallel
   * on each of the scattered parts.
   */
  sealed trait Scatter[A] extends Task {
    /**
     * Produces a new [[Scatter]] from the existing scatter. Takes a function that maps an individual
     * object of type A to a [[Task]] of type B.  During scatter/gather operation this function will
     * be invoked with each A, to manufacture tasks of type B.
     *
     * The resulting Scatter[B] can be further mapped or gathered (or both!).
     */
    def map[B <: Task](f: A => B) : Scatter[B]

    /**
     * Produces a [[Gather]] object which will be used at runtime to manufacture a [[Task]] of type B
     * which can gather things of type A.
     */
    def gather[B <: Task](f: Seq[A] => B) : Gather[A,B]

    /**
      * Produces a new [[Scatter]] from the existing scatter. Takes a function that maps an individual
      * object of type A to a key of type K to partition the task of type A.  Then takes a function
      * to manufacture a [[Task]] of type B from the given key of type K and partition of objects of type A.
      *
      * The resulting Scatter[B] can be further mapped or gathered (or both!).
      */
    def groupBy[K, B <: Task](f: A => K, g: (K, Seq[A]) => B) : Scatter[B]
  }


  /**
   * Represents a gather operation in a scatter/gather pipeline.
   */
  sealed trait Gather[A, B <: Task] extends Task {
    private[ScatterGather] var sources: Option[Seq[A]] = None
  }

  /** Implementation of a Gather that performs a single All->One gather operation. */
  private class SingleGather[A,B <: Task](f: Seq[A] => B) extends Gather[A,B] {
    override def getTasks: Traversable[_ <: Task] = sources match {
      case None    => throw new IllegalStateException("Gather.getTasks called before sources populated.")
      case Some(a) => Some(f(a))
    }
  }


  /**
  * Implementation of a Scatter that is just a thinly veiled wrapper around the Scatterer
  * being used to generate the set of scatters/partitions to operate on.
  */
  private class PartitionerWrapper[A](partitioner: Partitioner[A]) extends Scatter[A] {
    override def getTasks: Traversable[_ <: Task] = Some(partitioner)

    override def gather[B <: Task](f: Seq[A] => B): Gather[A,B] =
      throw new UnsupportedOperationException("gather not supported on an unmapped Scatter")

    override def map[T <: Task](f: A => T): Scatter[T] = {
      val sub = new PrimarySubScatter(partitioner, f)
      this ==> sub
      sub
    }


    override def groupBy[K, B <: Task](f: A => K, g: (K, Seq[A]) => B) : Scatter[B] = {
      val grouper = new PrimaryGrouper(partitioner, f, g)
      this ==> grouper
      grouper
    }
  }

  /**
  * Sub-trait of scatter that exists solely because we need two sub-types that share some common functionality.
  * Provides the tracking of tasks generated by the Scatter, sub-Scatters that need to be invoked and wired in
  * when the partitions are available and the set of Gathers to be performed on this stage of the Scatter.
  */
  private trait SubScatter[A, B <: Task] extends Scatter[B] {
    val tasks    = new ListBuffer[B]
    val subs     = new ListBuffer[SecondarySubScatter[B, _ <: Task]]
    val gathers  = new ListBuffer[Gather[B, _ <: Task]]
    val groupers = new ListBuffer[SecondaryGrouper[_, B, _ <: Task]]

    /** Ensures that gathers are wired in correctly. */
    protected def connectGathersAndGroupers(): Unit = {
      val taskList = this.tasks.toList

      gathers.foreach(gather => {
        gather.sources = Some(taskList)
        taskList.foreach(task => task ==> gather)
      })

      groupers.foreach { grouper =>
        taskList.foreach(task => task ==> grouper)
        grouper.chain(taskList)
        grouper.connectGathersAndGroupers()
      }

      subs.foreach(_.connectGathersAndGroupers())
    }

    override def map[T <: Task](f: B => T): Scatter[T] = {
      val sub = new SecondarySubScatter[B,T](f)
      this.subs += sub
      sub
    }

    override def gather[G <: Task](f: Seq[B] => G): Gather[B,G] = {
      val gather = new SingleGather[B,G](f)
      this.gathers += gather
      gather
    }

    override def groupBy[K, T <: Task](f: B => K, g: (K, Seq[B]) => T): Scatter[T] = {
      val grouper = new SecondaryGrouper[K, B, T](f, g)
      this.groupers += grouper
      grouper
    }
  }

  /**
  * A type of Scatter that is used to represent the first round of Scatter operation after the
  * partitioner has created the partitions.  It's tasks are generated using the scatter partitions
  * as input, and is also responsible for chaining together sub-scatters.
  */
  private class PrimarySubScatter[A, B <: Task](private val partitioner: Partitioner[A], f: A => B) extends Pipeline with SubScatter[A,B] {
    override def build(): Unit = {
      val as: Seq[A] = partitioner.partitions match {
        case Some(seq) => seq
        case None      => throw new IllegalStateException("Scatter/Gather pipeline trying to build before scatters populated.")
      }

      // Create the list of tasks and chain of sub-scatterers
      as.foreach { scatter: A =>
        val task: B = f(scatter)
        this.tasks += task
        root ==> task
        subs.foreach(sub => task ==> sub.chain(task))
      }

      connectGathersAndGroupers()
    }
  }

  /**
  * A type of scatter that is found at stage 2 and beyond where the input is guaranteed to
  * be a Task already, and not a partition on some domain type (e.g. intervals).
  */
  private class SecondarySubScatter[A <: Task, B <: Task](f: A => B) extends SubScatter[A,B] {
    def chain(a: A): B = {
      val task = f(a)
      this.tasks += task
      this.tasksDependingOnThisTask.foreach(other => task ==> other)
      this.tasksDependedOn.foreach(other => other ==> task)
      subs.foreach(sub => task ==> sub.chain(task))
      task
    }

    override def getTasks: Traversable[_ <: Task] = {
      throw new UnsupportedOperationException("getTasks is not supported and should never be called on sub-scatters.")
    }
  }

  /**
    * A type of Scatter that is used to represent the first round of Scatter operation after the
    * partitioner has created the partitions.  It's tasks are generated using the scatter partitions
    * as input, and is also responsible for chaining together sub-scatters.
    */
  private class PrimaryGrouper[K, A, B <: Task](private val partitioner: Partitioner[A], f: A => K, g: (K, Seq[A]) => B) extends Pipeline with SubScatter[A,B] {
    override def build(): Unit = {
      val as: Seq[A] = partitioner.partitions match {
        case Some(seq) => seq
        case None      => throw new IllegalStateException("Scatter/Gather pipeline trying to build before scatters populated.")
      }

      // Create the list of tasks and chain of sub-scatterers
      as.groupBy(f).foreach { case (k, v) =>
        val task = g(k, v)
        this.tasks += task
        root ==> task
        subs.foreach(sub => task ==> sub.chain(task))
      }

      connectGathersAndGroupers()
    }
  }

  /** Implementation of a Scatter that performs a groupBy operation on the given sources. */
  private class SecondaryGrouper[K, A, B <: Task](val f: A => K, val g: (K, Seq[A]) => B) extends SubScatter[A, B] {
    def chain(tasks: Seq[A]): Iterable[B] = {
      tasks.groupBy(f).map { case (k, v) =>
        val task = g(k, v)
        this.tasks += task
        this.tasksDependingOnThisTask.foreach(other => task ==> other)
        this.tasksDependedOn.foreach(other => other ==> task)
        subs.foreach(sub => task ==> sub.chain(task))
        task
      }
    }

    override def getTasks: Traversable[_ <: Task] = {
      throw new UnsupportedOperationException("getTasks is not supported and should never be called on groupers.")
    }
  }
}
